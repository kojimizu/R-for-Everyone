---
output:
  html_document: default
  pdf_document: default
  word_document: default
---

R for Everyone Codebook 
Code review 
Chap5: - 2017/12/25
Chap6: 2017/12/25 - 
Chap7: 
Chap11: 1/5
Chap12: 1/6

- data()
  - ggplot2: diamonds

- function()
  - XML: readHTMLTable, 

---------------------------------
# Chapter4: Basic command
## 4.1 Basics
## 4.2. Variable
```{r}
x<--2
y=5
assign("j",4)
j
```

## 4.3 Data
### 4.3.1 Numerical data
```{r}
class(x) #"numeric"
is.numeric(x) #TRUE
i<-5L #integer
is.integer(i) #TRUE
is.numeric(i) #TRUE
class(4L) #integer
class(2.8) #numeric
```

### 4.3.2 Text data
```{r}
x<-"data"
y<-factor("data")
y<-"data"
class(x) #character
nchar(x) #4 = number of character
nchar(452) #3
nchar(y) #error - y requires a character vector
```

### 4.3.3 date
```{r}
date1<-as.Date("2012-06-28")
class(date1) #date
as.numeric(date1) #15519

date2<-as.POSIXct("2012-06-28 17:42")
date2
class(date2) #[1] "POSIXct" "POSIXt" 
as.numeric(date2) #[1] 1340872920
```

Lubridate, chron packages are used to treate time or date such as an object.
-as.numeric/as.date (): change the type of object
```{r}
class(date1) #date
class(as.numeric(date1)) #numeric
```

### 4.3.4 Logical 
logical is binary values eithrer TRUE(1) or FALSE (0)
```{r}
TRUE*5 #5
FALSE*5 #0

k<-TRUE
class(k) 
is.logical(k) #TRUE
2==3
2!=3
2<3
2<=3
"data" < "stat" #number of character
class("data")

```

## 4.4 Vector
### 4.4.1 vector calculation
We set the basic vector, and can calculate sum/deduct/devide without loop.
```{r}
x<-c(1,2,3,4,5,6)
x+2
x-3
x^2
sqrt(x)
```

c is the function to create a vector, and we can use ":" operator, to calculate sequential numbers. 
```{r}
1:10
10:1
-2:3
5:-7
```

Vector operator can be expanded (e.g., there are two vectors with same length, and computation of each vector components once).
```{r}
x<-1:10
y<--5:4
x+y
x-y
x/y  
x**y # x^y: x to yth power
length(x)
length(x*y)
```

Two vectors with different length needs more complex computation.
Generally, a vector with shorter length is used multiple times. 

```{r}
x+c(1,2)
x+c(1,2,3)

x<=5
x>y
```

All function is used to test whether all values satisfy comparative statistics. 
```{r}
x<- 10:1
y<- -4:5
all(x<y)
```
 
- nchar function is used toward each component of vector.
```{r}
q<-c("Hockey","Football","Baseball","Curling","Rugby",
     "Lacrosse", "Bascketball","Tennis","Cricket","Soccer")
nchar(q)
nchar(y)
```

To access vector coponent, [] is used. To extract first component of x vector, x[1], x[1:2] for first two components. If components to be extracted are not sequential, x[c(1.4)] expression is usefl.
```{r}
x[1]
x[1:2]
x[c(1,4)]
```

The [] expression works for numeric, logical, character classes. We can also name vector before/after making a vector.
```{r}
c(One="a",Two="y",Last="r")
w<-1:3
names(w)<-c("a","b","c")
w
```

### 4.4.2 Factor vector
Factor is a crucial concept to construct a model.
First, we add additional components to the vector q.
```{r}
q2<-c(q,"Hockey","LAcrosse","Hockey","Water Polo",
      "Hockey","LAcrosse")
```

We can transform this vector into factor by as.factor function.
```{r}
q2Factor<-as.factor(q2)
q2Factor
```

After q2Factor components are listed, levels are also listed. Factor's level lists non-duplicate figures. 

```{r}
as.numeric(q2Factor)
```

Geenrally, no attention to the order of levels is required for factor. In addition, all level are treated same. However, there are occations factor order becomes significant.Ordered argument is set TRUE so that factor is ordere according to level argument.
```{r}
factor(x=c("High School","College","Masters","Doctorate"),
       levels=c("High School","College","Masters","Doctorate"),
       ordered=TRUE)
```

Factor keeps identical items, we could reduce size of variables.

## 4.6 Function command
apropos() is useful to search specific function by keyword
```{r}
apropos("mea")
?kmeans
```

## 4.7 Missing Value "欠損値"
Missing value plays an important role for statistics and calculation. There are two types of missing values; NA and NULL.

### 4.7.1 NA
NA is shown as a component of vector. is.na() could test whether there is any missing value in vector.
- is.na: test existence of missing value
```{r}
z<-c(1,2,NA,8,3,NA,3)
z
is.na(z)
```

NA can be input by inserting NA, and corresonds to every class of vector. 
```{r}
zChar<-c("Hockey",NA,"LAcrosse")
zChar
is.na(zChar)
```

多重代入法 is a popular method to deal with statistical analysis. Details is available in chapter 25 of "Data Analysis Using Regression and Multilevel/Hierachical Models".

### 4.7.2 NULL
NULL cannot be insite vector, as it disappears in the vector after its used. 
```{r}
z<-c(1,NULL,3)
z
```

NULL is not saved in the c vector.We can test if there is any NULL item by is.null function ().
```{r}
d<-NULL
is.null(d)
is.null(7)
```

---------------------------------
#Chapter 5: High level data structure
We can treat high dimentional/level data frame by R, with data.frame, matrix, list,array.

## 5.1. data.frame
data.frame is similar to excel spreadsheet with row/columns(obs - row, variables - columns).Each column has a same length vector, and can be treated with different class of data.The data.frame function () is frequently used to form data.frame.

```{r}
x<-10:1
y<--4:5
q<-c("Hockey","Football","Baseball","Curling","Rugby",
     "Lacrosse","Bascketball","Tennis","Cricket","Soccer")
theDF<-data.frame(x,y,q)
theDF
```

In the above code, 10*3 data.frame was formed. Each column name can be changed in the data.frame function.
```{r}
theDF<-data.frame(First=x, Second=y, Sport=q)
theDF
```

The data.frame is a complex obeject with multiple characters. To quickly check number of rows/colmns, nrow/ncolumn () functions are used.
```{r}
nrow(theDF)
ncol(theDF)
dim(theDF)
```

Name () function is used to check name of columns, and such column names can be changed easily. 
```{r}
names(theDF)
names(theDF)[3]

rownames(theDF)
rownames(theDF)<- c("One","Two","Three","Four","Five","Six","Seven","Eight","Nine","Ten")
rownames(theDF)
rownames(theDF)<-NULL
rownames(theDF)
```

head () function is useful for checking first few rows. class function () can be used to detect data.frame.
```{r}
head(theDF)
head(theDF,n=7)
tail(theDF)
class(theDF)
```

data.frame has each column as individual vector with different class, thus , thus we can access each column.For accesing specific row, argument "$" or "[]" could be used.

```{r}
theDF$Sport
theDF[3,2] # For [], we need to input row/column no.
theDF[3,2:3]
theDF[c(3,5),2] #row3, 5 with column 2
theDF[,c("First","Sport")]
```

```{r}
#Sport column only
theDF[,"Sport"]
class(theDF[,"Sport"]) #factor is reverted as its only one column
theDF["Sport"]
class(theDF["Sport"])
```

drop=FALSE is set if we want to extract only one column data.frame with [].
```{r}
theDF[,"Sport",drop=FALSE]
class(theDF[,"Sport",drop=FALSE])
theDF[,3,drop=FALSE]
class(theDF[,3,drop=FALSE])
```

In section 4.4.2, factor is a special class, and we would like to confirm that such class can be exressed in data.frame as well.
- Model.matrix() is used with indicator variables (dummy).This results in 1 in case such row includes such level, otherwise 0.
```{r}
newFactor<-factor(c("Pennsylvania","New York","New JErsey","New York","Tennessee","Massachusetts","Pennsylvania","New York"))
model.matrix(~newFactor-1)
```

## 5.2 List
there is a case we need a List storing multiple types of objects.List can deal with numeric, character, both, and even data.frame.
```{r}
list(1,2,3) # three components
list(c(1,2,3)) # one vector with three components

list3<-list(c(1,2,3),3:7)
# first: a vector with three comps
# second: a vector with five comps

list4<-list(theDF,1:10)
list4
# second: a vector with ten numbers
```

The list can be named with names() function. Use pair of name and figures when list is created to give name. 
```{r}
list5<-list(theDF, 1:10, list3)

names(list5)
names(list5)<-c("data.frame","vector","list")
list5

list6<-list(TheDataFrame=theDF, THeVector=1:10, TheList=list)
names(list6)
```

Vector () function is used to make a ideal length of blank list. 
```{r}
(emptyList<-vector(mode="list",length=4))
```

To access each component of list, we should use [[]], and set number or name. By this function, only one item can be accessed.
```{r}
list5[[1]]
list5[["data.frame"]]

list5[[1]]$Sport
list5[[1]][,"Second"]
list5[[1]][,"Second",drop=FALSE]
```

To add new component to list, new syntax (number or name) is attached.
```{r}
length(list5)
list5[[4]]<-2 #without name
length(list5)

list5[["NewElement"]]<-3:6
list5
```


## 5.3 Matrix
Matrix is a basic mathmatical structure. There are row, column, similar to data.frame, however, all components are required to be same class/type in matrix. The most common matrix is numeric, and add/deduct/multiply/divide can e calculated. - nrow ()
- ncol ()
- dim () functions are available
```{r}
A<-matrix(1:10,nrow=5)
B<-matrix(21:30,nrow=5)
C<-matrix(21:40,nrow=2)
A
B
C
```

```{r}
# matrix basic calculation
# To calculate A*B, A's column and B'row need to be indentical
A+B
A*B
A==B
```

Transposed matrix can be calculated with t() function. 

```{r}
# Transposed matrix
A %*% t(B)
colnames(A)<-c("Left","Right")
rownames(A)<-c("1st","2nd","3rd","4th","5th")
colnames(B)<-c("First","second")
rownames(B)<-c("One","Two","Three","Four","Five")

colnames(C)<-LETTERS(1:10)
rownames(C)<-c("Top","Bottom")
```

When matrix is transposed, we should be careful that row name and column name is conversed. 
```{r}
t(A) # A:5*2 C:2*5
A %*% C
```


## 5.4 Array
Array is multidimentional vector. Array's components need to have same type. [] can be used to access specific component,like Vector. In[], the first item is row number, second is column number etc. 

The difference between matrix and array is that array can be used for non-limited dimension, while matrix is limited to second dimension.

```{r}
theArray<-array(1:12,dim=c(2,3,2))
theArray
```

```{r}
theArray[1,,]
theArray[1,,1]
theArray[,,1]
```


---------------------------------
# Chapter6: Loading data

## 6.1. Loading CSV file
CSV file can be easily loaded using read.table function. 
- read.table(): if CSV is loaded as data.frame. 
 - file: the file to be loaded
 - header: Yes, if first row is column name
 - sep: Mark to split data (",")
 - stringAsFactors: FALSE to prevent make character column into factor column (character column is easier to deal as data)
 
* stringAsFactors is used also for data.frame.

```{r}
theURL<-"http://www.jaredlander.com/data/Tomato%20First.csv"
tomato<-read.table(file=theURL,head=TRUE,sep=",")
head(tomato)
```

When we proces theDF data, the theDF$Sport is easier to analyze. There are multiple arguments available for read.table () function.
- quote: used when data is labled with ""
- colClasses:set each column's data class/type

```{r}
x<-10:1
y<--4:5
q<-c("Hockey","Football","Baseball","Curling","Rugby","Lacrosse","Basketball","Tennis","Cricket","Soccer")
theDF<-data.frame(First=x,Second=y,Sport=q,stringAsFactors=FALSE)
theDF$Sport
```

In case where CSV file uses ,(区切文字) in each data.
- read.csv2(or read.delim2)

## 6.2. Loading Excel data
The easiest way to load excel file is to transform excel to CSV file. Even though there are packages such as gdata, XLConnect, xlsReadWrite, these packages require JAVA/Perl.

## 6.3. Loading from Database
Most database provides ODBC connectin, for instance, Mocrosoft SQL server, DB2, MySQL, Miscrosoft Access. Thus, R allows ODBC by RODBC package. 

(1) Construct DSN: 
DSN is constructed as sentence for odbcConnect ().
- argument uid
- password
(2) 

```{r}
install.packages("RODBC")
require(RODBC)
db<-odbcConnect("QV Training")
```

By the above command, we are read to run query on database. sqlQuery () function is used, and very usefl for any complet SQL query. sqlQuery provides data.frame, and has a stringAsFactors as its argument. 
```{r}
# simple select
ordersTable<-sqlQuery(db,"SELECT*FROM Orders",
                      stringsAsFactors=FALSE)
detailsTable<-sqlQuery(db, "SELECT*FROM[Order Details",
                      stringsAsFactors=FALSE)
# join two tables
longQuery<-"SELECT * FROM Orders, [Order Details]
WHERE Orders.ORderID = [Order Details].OrderID"
detailsJoin<-sqlQuery(db, longQuery, stringsAsFactors=FALSE)

head(ordersTable)
head(detailsTable)
heead(detailsJoin)
```

## 6.5 R Binary File
RData file is useful to transfer data to another R programmer. RData file is a binary file as a object or multiple pbjects, and can be transfered through Windows, Mac, Linux.

```{r}
# save tomato data.frame
save(tomato,file="C:/Users/kojikm.mizumura/Desktop/Data Science/みんなのR/tomato.rdata")
rm(tomato)
head(tomato)
load("C:/Users/kojikm.mizumura/Desktop/Data Science/みんなのR/tomato.rdata")
head(tomato)

n<-20
r<-1:10
save(n,r,w,file="C:/Users/kojikm.mizumura/Desktop/Data Science/みんなのR/3. Dataset/multiple.rdata")
rm(n,r,w)
load("C:/Users/kojikm.mizumura/Desktop/Data Science/みんなのR/3. Dataset/multiple.rdata")
```

## 6.6 Default Packages
To check available default datasets in each package, data() function is useful.
  
```{r}
data()
```

##6.7 Webscraping

readHTMLTable () function:
- which: pick which table in case there are multiple tables
- Header: No, in case there no header in table
- stringAsFactors: FALSE not to make character column into factor

```{r}
install.packages("XML")
require(XML)
theURL1<-"https://www.jaredlander.com/2012/02/another-kind-of-super-bowl-pool/"
bowlPool<-readHTMLTable(theURL1, which=1, header=FALSE,
                        stringsAsFactors=FALSE)
bowlPool
```

---------------------------------
# Chap7: Statistical Graph
## 7.1 Basic graphics

### 7.1.1. Histogram
Basic graph for one variable is histogram. 
- diamonds dataset: distribution by Carat
```{r}
require(ggplot2)
data(diamonds)
head(diamonds)
```

```{r}
hist(diamonds$carat, main="Carat Histgram",xlab="Carat")
```


### 7.1.2 Scatterplot
Scatterplot is useful to plot two variables 
- diamonds dataset: 
```{r}
plot(price~carat, data=diamonds)
plot(diamonds$carat, diamonds$price)
```

### 7.1.3 Boxplot
The Box plot shows 1st and 3rd quartile (50% range from center is ciculated)
```{r}
boxplot(diamonds$carat)
```

## 7.2 ggplot2
###7.2.1 Histgraom Density chart by ggplot
ggplot has a complex syntax (structure), but allows user to dipict by size,shape, color etc. 

```{r}
install.packages("ggplot2")
require(ggplot2)
ggplot(data=diamonds)+geom_histogram(aes(x=carat))
```

```{r}
ggplot(data=diamonds)+geom_density(aes(x=carat), fill="grey50")
```

### 7.2.2. Scatterplot by ggplot
```{r}
ggplot(diamonds, aes(x=carat,y=price))+geom_point()
g<-ggplot(diamonds,aes(x=carat,y=price))
g+geom_point(aes(color=color))
g+geom_point(aes(color=color))+facet_wrap(~color)
g+geom_point(aes(color=color))+facet_grid(cut~clarity)
```

### 7.2.3 Boxplot / Violin-plot by ggplot
Violin plot is simiar to boxplot, but provides more information than boxplot. By using violin plot, we can depict multiple layers (geoms) at the same chart.
```{r}
ggplot(diamonds, aes(y=carat, x=1))+geom_boxplot()
ggplot(diamonds, aes(y=carat,x=cut))+geom_boxplot()

ggplot(diamonds, aes(y=carat,x=cut))+geom_violin()
ggplot(diamonds,aes(y=carat,x=cut))+geom_point()+geom_violin()
ggplot(diamonds,aes(y=carat,x=cut))+geom_point()+geom_point()
```

### 7.2.4 Line by ggplot

ggplot2 depicts economics pop line by identifying date data.
However, there are cases we need to input aes(group=1) for geom_line(). 

```{r}
head(economics)
ggplot(economics,aes(x=date,y=pop))+geom_line()
```

---------------------------------------
# Chap8: Write R Function

## 8.1 Hello World
simple function to show "Hello, World".
- perod (.) does not have a special meaning
- Similar other arguments, "<-" assigns function to object same as variabile
```{r}
say.hello<-function()
{
  print("Hello, World!")
}
```

## 8.2 Argument of function
sprintf () function 
- first argument:special input word
- second argument:next word
```{r}
sprintf("Hello %s", "Jared") # one word
sprintf("Hello %s, today is %s", "Jared","Sunday") # two words

hello.person<-function(name)
{
  print(sprintf("Hello %s",name))
}
hello.person("Jared")
hello.person("Bob")
hello.person("Sarah")
```

Argument can be used as a variable in function, and can be treated same as other variables and argument to further call for another function inside the function.
```{r}
hello.person<-function(first,last)
{
  print(sprintf("Hello %s %s",first, last))
}

# set by position
hello.person("Jared","LAnder")
# set by name
hello.person(first="Jared",last="Lander")
# set by name in oppostite
hello.person(last="Lander", first="Jared")
# set by one name
hello.person("Jared",last="Lander")
hello.person(first="Jared","Lander")
hello.person(last="Lander","Jared")
```

### 8.2.1 Default argument
R has a default setting for multiple arguments (no need to set argument individually). 

```{r}
hello.person<-function(first,last="Doe")
{
  print(sprintf("Hello %s %s", first, last))
}
hello.person("Jared") #not set last name
hello.person("Jared","Lander") #set different last name
```


### 8.2.2 Additional argument 
R has a special operator ("演算子", "..."") allow function to take arguments not needed for defining function.
```{r}
# Additional argument
hello.person("Jared",extra="Goodbye") #error

# two effective arguments, extract third argument
hello.person("Jared","Lander","Goodbye")

hello.person<-function(first,last="Doe",...)
{
  print(sprintf("Hello %s %s",first,last))
}
hello.person("Jared",extra="Goodbye")
hello.person("Jared","Lander","Goodbye")
```

## 8.3 Return value
Function is generally used to calculate some values, and needs mechanism to retrun calculation results back to function.

There are two methods for R
- (1) return last row value automatically
- (2) use return command to select which value to be returned/which function to be closed (finished)

```{r}
# make function without specific definition
double.num<-function(x)
{ x*2}
double.num(5)

# define return mechanism
double.num<-function(x)
{return(x*2)}
double.num(5)

# additional argument of 17 after return x* value / x*2 function is already over, and the code was not conducted
double.num<-function(x)
{return(x*2)
  print("Hello!")
  return(17)}
double.num(5)
```

## 8.4 do.call
do.call () function is used to set name of function (not frequently used).List is used to set arguments.

```{r}
do.call("hello.person",args=list(first="Jared",last="Lander"))
do.call(hello.person,args=list(first="Jared",last="Lander"))

run.this<-function(x,func=mean)
{
  do.call(func,args=list(x))
}
run.this(1:10,mean) #set average
run.this(1:10,sum) #set sum
run.this(1:10,sd) #set sd
```


---------------------------------------
# Chapter9: Control Sentence
Control sentence controls program and allows different codes based on test result (e.g., logic, TRUE, FALSE). Main control sentences are as follows.
- if
- else
- ifelse
- switch

## 9.1 if and else
```{r}
as.numeric(TRUE)
as.numeric(FALSE)

1==1
1<1
1>=1
1!=1

# if sentence to control this test
toCheck<-2
if(toCheck==1)
{
  print("hello")
}

```


if sentence is close to function in terms that all sentences are within (). We define else sentence in case the the situation is FALSE circumustance. 
- TRUE: works as 1 (TRUE)
```{r}
check.bool<-function(x)
{
  if(x==1)
  {
    print("hello") # if x=1, "Hello"
  } else
  {
    print("goodbye") #otherwise "goodbye"
  }
}
check.bool(1)
check.bool("k")
check.bool(TRUE)
```

In case of testing multiple options, we use else if () respectvely. 
```{r}
check.bool<-function(x)
{
  if(x==1)
  {
    print("Hello")
  }else if (x==0)
  {
    print("Confused")
  }else
  {
    print("Unknown")
  }
}
check.bool(1)
check.bool(0)
check.bool("k")
```

## 9.2 Switch 
When we test multiple options , switch would be more useful than else if 
- first argument: values to be tested
- second argument: option values, results
```{r}
use.switch<-function(x)
{
  switch(x,
         "a"="first",
         "b"="second",
         "z"="last",
         "c"="third",
         "other")
}
use.switch("a")
use.switch("e")
```

When the first argument is numerical, order of the first argument is used instead of name of the first argument. 
```{r}
use.switch(1)
use.switch(4)
```

## 9.3. ifelse
ifelse is close to if function in excel.
- first: condition to be tested
- second: returned value when the test is TRUE
- third: returned value whenthe test is FALSE
```{r}
# test whether 1=1
ifelse(1==1, "Yes","No")
ifelse(1==0, "Yes","No")
toTest<-c(1,1,0,1,0,1)
ifelse(toTest==1, "Yes","No")

# we can access element of first argument (test value)
ifelse(toTest==1, toTest*3, toTest)
ifelse(toTest==1, toTest*3, "Zero")

# NA value
toTest[2]<-NA
toTest
ifelse(toTest==1, "Yes","No")
ifelse(toTest==1, toTest*3, toTest)
ifelse(toTest==1, toTest*3, toTest)
ifelse(toTest==1, toTest*3, "ZERO")
```

## 9.4 Multiple tests

When testing multiple conditions, double expressin (e.g.,&&, ||) are used in the same if sentence.The expression "and" (multiply) is priotized against "or" (add).

```{r}
a<-c(1,1,0,1)
b<-c(2,1,0,1)
# check condtion a and b respectively
ifelse(a==1 & b==1, "Yes", "No")
# check condition a and b as one condition
ifelse(a==1 && b==1, "Yes", "No")
```

-----------------------
# Chapter10: Loop
R beginners often use vector, list, data.frame with loop functions. It is desirable to use vecotrized coding, but the below outlines for loop, while loop functions.

## 10.1 For Loop

For loop function is most frequently used. 
- for loop: iterate process for index (vector)

```{r}
for (i in 1:10)
{print(i)}

# print () function (vectorized) works for the same results 
print(1:10)
```

For loop function works for any value/inputs.
```{r}
# vector listing fruit name
fruit<-c("apple","banana","pomegranate")
fruitLength<-rep(NA,length(fruit))
fruitLength
# [1] NA NA NA

names(fruitLength)<-fruit
fruitLength

for(x in fruit)
{fruitLength[x] <-nchar(x)}
fruitLength
```

The above can be accomplished by a vectorized function in R. 
```{r}
fruitLength2<-nchar(fruit)
names(fruitLength2)<-fruit
fruitLength2
identical(fruitLength,fruitLength2)
```

## 10.2 While Loop
It is easy to implement While Loop as well as For Loop, as the While Loop iterates the parenthis until condition is TRUE/satisfied.
```{r}
x<-1
while(x<=5)
{
  print(x)
  x<-x+1
}
```

## 10.3 Loop control
Next/Break are used in R to control iteration process of loop.
```{r}
## 3 is not generated as output
for (i in 1:10)
{
  if (i==3)
  {
    next
  }
    print(i)
}
```

The process is stopped at 3 by settung break argument 
```{r}
for (i in 1:10)
{
  if (i==4)
  {
    break
  }
  print(i)
}
```

------------------------
# Chapter11: Grouping control
We must spend most time to process data, and there are multiple useful functions as follows. 

## 11.1 Apply family
- tapply 
- lapply 
- sapply 
- mapply 

### 11.1.1 Apply
The most limited function which can be applied to matrix only with categorical/numeric/logic. 
* If apply function is applied to data.frame, it is converted to matrix. 

- first argument: data object
- second argument: margin to be applied to function (1: row, 2: column, 3: function, 4: additional conditions to function operation). 

The apply function iterates processing each row (column) by applying its function to it as independent input.

```{r}
theMatrix<-matrix(1:9, nrow=3)

# apply to sum by row 
apply(theMatrix, 1, sum)
# apply to sum by column 
apply(theMatrix, 2, sum)

# the above calculation can be simplified by using rowSums, colSums functions. 
rowSums(theMatrix)
colSums(theMatrix)
```

We check NA values (#欠損値) in apply function.

```{r}
theMatrix[2,1]<-NA
apply(theMatrix,1,sum)
apply(theMatrix,1,sum,na.rm=TRUE)
rowSums(theMatrix)
rowSums(theMatrix, na.rm=TRUE)
```

## 11.1.2 lapply/sapply

- lapply: apply function to each element of list, and return the results as list.
```{r}
theList<-list(A=matrix(1:9,3),B=1:5,C=matrix(1:4,2),D=2)
lapply(theList, sum)
```

- sapply: returns lapply results by vector (this is identical to sapply except for output type).
```{r}
sapply(theList, sum)

theNames<-c("Jared","Deb","Paul")
lapply(theNames, nchar)
```

### 11.1.3 mapply
- mapply: apply selected function to each element of multiple lists (unfortunately, we might try to use loop function, being unware of mapply).
```{r}
# prepare two lists
FirstList<-list(A=matrix(1:16,4), B=matrix(1:16,2),C=1:5)
SecondList<-list(A=matrix(1:16,4),B=matrix(1:16,8),C=15:1)

# check whether element matches  between both lists
mapply(identical, FirstList, SecondList)

# define function
simpleFunc<-function(x,y)
{NROW(x)+NROW(y)}

#apply function
mapply(simpleFunc, FirstList, SecondList)

```

### 11.1.4 Other apply function
There are other functions (eg, tapply,rapply,eapply,vapply,by), but replaced by plyr package.

## 11.2 Aggregate
Aggregate function is used fro grouping operation etc.
- dataset:diamonds (ggplot library)

Example as below
- First argument: 
- Second argument: data
- Third argument: function to be applied
```{r}
require(ggplot2)
data(diamonds)
head(diamonds)
aggregate(price~cut, diamonds, mean)
```

In the first argument, we set price to be aggregated by cut. The data is given as second argument, thus onl column names are input as the first argument.

When we group a data by multiple variabiles, symbol "+" is added. However, we need to bind variables by cbind() function, when we want to group two variables.
```{r}
aggregate(price~cut+color,diamonds,mean)
aggregate(cbind(price, carat)~cut, diamonds,mean)
```

The above function gives us mean value for price and carat by cut category. When we apply multiple functions, plyr package is preferable. 

```{r}
aggregate(cbind(price,carat)~cut+color,diamonds,mean)
```

## 11.3 plyr
The core functions of plyr package are ddply, llply and ldply.
- First letter:input data class
- Second letter: output data class

ddply(data-data.frame), llply(data-list), ldply(input-list,output-data.frame)

Function | input | output
:---------|:---------:|---------:
ddply|data.frame|data.frame
llapply|list|list
aapply|array/vector/matrix|array/vector/matrix
dlply||data.frame|list

### 11.3.1 ddply
- dataset:baseball (plyr package)
```{r}
require(plyr)
head(baseball)
```

The statistics OBP (On Base Percentage) is caculaged as OBP = (H+BB+HBP) / (AB+BB+HBP+SF)
- H: Hit
- BB: Four Ball
- HBP: Dead ball
- AB: At Bat (Dasuu)
- SF: Sacrifice fly (Gisei Fly)

```{r}

# Transforms NA in sf to 0
baseball$sf[baseball$year<1954]<-0
any(is.na(baseball$sf))

# Transforms NA in HBP to 0
baseball$hbp[is.na(baseball$hbp)]<-0
any(is.na(baseball$hbp))

# Picks palyers with more tha 50 ABs
baseball<-baseball[baseball$ab>=50,]

# Calculate OBP (On Base Percentage)
baseball$OBP<-with(baseball,(h+bb+hbp)/(ab+bb+hbp+sf))
tail(baseball)
```

The with() function is used to refer specific columns within data.frame. However, when we calculate lifetime OBP for each player, we need to sum numerator/denominator figures first.

We define function and use ddply for calculating lifetime OBP per player. 

```{r}
# We assume that the below column names are defined in dataset.
obp<-function(data)
{c(OBP=with(data,sum(h+bb+hbp)/sum(ab+bb+hbp+sf)))}

# apply ddply to calculate lifetime OBP per player
careerOBP<-ddply(baseball, .variables="id",.fun=obp)

#Change order by Lifetime OBP ratio
careerOBP<-careerOBP[order(careerOBP$OBP,decreasing=TRUE),]
head(careerOBP,10)
```

### 11.3.2 llply

We can use llply to calculate sum of elements in each list.
```{r}
theList<-list(A=matrix(1:9,3), B=1:5,C=matrix(1:4,2),D=2)
laply(theList, sum)

llply(theList, sum)
identical(lapply(theList,sum),llply(theList,sum))
```

laply() function can be used to return results by vector, as well as sapply() function.
```{r}
sapply(theList, sum)
laply(theList,sum)
```

### 11.3.3 Plyr helper function
Plyr has multiple help functions such as each() function for aggregate() function.
```{r}
require(ggplot2)
aggregate(price ~ cut, diamonds,each(mean,median))
```

The other useful function is idata.frame() function. This function refers data frame for rapid operation.
```{r}
system.time(dlply(baseball,"id",nrow))
iBaseball<-idata.frame(baseball)
system.time(dlply(iBaseball,"id",nrow))
```

Sometimes, plyr is criticized fro its slow operation. 

## 11.4 Data.table
For speedy operation, data.table  package is used by expanding data.frame functionality.The syntax is different from regular data.frame.Data.table enables us to access/grouping/combine(JOIN) data rapidly.  
```{r}
install.packages("data.table")
require(data.table)
theDF<-data.frame(A=1:10,
                  B=letters[1:10],
                  C=LETTERS[11:20],
                  D=rep(c("One","Two","Three"), length.out=10))
theDT<-data.table(A=1:10,
                  B=letters[1:10],
                  C=LETTERS[11:20],
                  D=rep(c("One","Two","Three"), length.out=10))

theDF
theDT

# Default: data.frame(factor), data.table(character)
class(theDF$B)
class(theDT$B)
```

The data in data.frame and data.table is identical except for the different data class. Data table can be generated from existing data.frame.
```{r}
diamondsDT<-data.table(diamonds)
diamondsDT

theDT[1:2,]
theDT[theDT$A>=7,]
```

In section 5.1, multiple columns are set as vector of character for data.frame. As for data.table, columns are selected as column name.
```{r}
theDT[,list(A,C)]

# One column
theDT[,B]

# On column keeping data.table structure
theDT[,list(B)]

# in case we set column name without list, we put with argument as FALSE.
theDT[,"B",with=FALSE]
theDT[,c("A","C"),with=FALSE]
```

### 11.4.1 Key
data.table are stoted on memory, and can be checked by data.table () function.

```{r}
# Show table
tables()
```

We input key for theDT table, by putting data.table. 
- setkey(): key setting
 - first: data.table to be used
 - second: column to be used

```{r}
# set key
setkey(theDT,D)
theDT

key(theDT)
tables()
```

By setting key function, we can utilize new approach to select rows from data.table. In addition to row number, TRU/FALSE, we can utlize column values set as key.
```{r}
theDT["One",]
theDT[c("One","Two"),]
```

Multiple columns are set as key. There is a specific functiona named J(), and we input multiple arguments.
- J()
```{r}
setkey(diamondsDT,cut,color)

# try order change
diamondsDT<-diamondsDT[order(diamondsDT$color,decreasing=TRUE),]

# J function to select multiple columns with keys
diamondsDT[J("Ideal","E")]
```

### 11.4.2 data.table aggregation
```{r}
aggregate(price~cut, diamonds,mean)
diamondsDT[,mean(price),by=cut]
diamondsDT[,list(price=mean(price)),by=cut]

# columns are set by list when we aggregate multiple columns
diamondsDT[,mean(price),by=list(cut,color)]

# aggreation of multiple arguments
diamondsDT[,list(price=mean(price),carat=mean(carat),by=cut)]

diamondsDT[,list(price=mean(price),carat=mean(carat),
                 caratSum=sum(carat)),by=cut]
```

Lastly, we set multiple agrregation / multiple grouping variables simultaneously.
```{r}
diamondsDT[,list(price=mean(price),carat=mean(carat)),
           by=list(cut,color)]
```


----------------------------------------------------

# Chapter 12: Data processing 
Data processing/cleaning to change the structure of data (row-based, column-based), or generate dataset from multiple data sources. 
- plyr
- reshape2
- data.table 

## 12.1 cbind and r bind

We would combine two vectors in data.frame format by cbind function, and accumulate data on row-base by rbind function. 
- cbind()
- rbind()
```{r}
# create two vectors and combine both by data.frame

#trophies1
sport<-c("Hockey","Baseball","Football")
league<-c("NHL","MLB","NFL")
trophy<-c("Stanley Cup","Commissioners Trophy", "Vince Lombardi Trophy")
trophies1<-cbind(sport,league,trophy)

trophies2<-data.frame(sport=c("Bascketball","Golf"), league=c("NBA","PGA"),trophy=c("Larry OBrien Championship Trophy", "Wanamaker Trophy"),stringsAsFactors = TRUE)

# combine both vectors (data.frame) by rbind() function.

trophies1
trophies2
trophies<-rbind(trophies1,trophies2)
```


multiple arguments are set to combine any number of objects together with cbind(), rbind() functions. 
- cbind(): we can change name of column of vectors in the argument.
```{r}
cbind(Sport=sport, Association=league, Prize=trophy)
```


## 12.2 Join 

Data is not ordered for simply combining by cbind() function. Thus, we need to comnine data by using key.

The most common data comine functions are
- merge(baseR package)
- join (plyr package)
- merge function of data.table

The exampke: csv files from USAID Open Government Initiative

```{r}
download.file(url="http://jaredlander.com/data/US_Foreign_Aid.zip",destfile="C:/Users/kojikm.mizumura/Desktop/Data Science/2. みんなのR/ForeignAid.zip")
unzip("C:/Users/kojikm.mizumura/Desktop/Data Science/2. みんなのR/ForeignAid.zip", exdir="data")
```

To load all csv files, we use for loop() function. We obtain list of files by dir function. We assign name to each data by assign() function.
- for loop():
- dir():

```{r}
require(stringr)

# obtain list of files
theFiles<-dir("C:/Users/kojikm.mizumura/Desktop/Data Science/2. みんなのR/data/",pattern="nn.csv")

# apply loop processing for these files
for (a in theFiles)
{
  #create name to be assigned to data
  nameToUse<-str_sub(string=a,start=12,end=18)
  # read.table() to load csv file
  # file.path() is for generating file path setting file and folder name
  temp<-read.table(file=file.path("C:/Users/kojikm.mizumura/Desktop/Data Science/2. みんなのR/data",a),header=TRUE,sep=",",stringsAsFactors = FALSE)
  #R workspace gets variables (Rのworkspaceに変数を割り当てる)
  assign(x=nameToUse,value=temp)
  }

```

### 12.2.1 Merge
Merge() function is used to combine two data.frame.
- by.x argument:set key for the left data.frame 
- by.y argument:set key for the right data.frame

However, merge() function is very slow compared with other similar functions.

```{r}
Aid90s00s<-merge(x=Aid_90s,y=Aid_00s,
                 by.x=c("Country.Name","Program.Name"),
                 by.y=c("Country.Name","Program.Name"))
head(Aids90s00s)
```

### 12.2.2 plyr join by Hadley Wickam

join() function (plyr package)
```{r}
require(plyr)


```


## 12.3 reshape2



## 12.4 summary





















