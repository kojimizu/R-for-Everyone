---
output:
  html_document: default
  pdf_document: default
  word_document: default
---

R for Everyone Codebook 
Code review 
Chap5: - 2017/12/25
Chap6: 2017/12/25 - 
Chap7: 


- data()
  - ggplot2: diamonds

- function()
  - XML: readHTMLTable, 

---------------------------------
# Chapter4: Basic command
## 4.2. Variable

```{r}
x<--2
y=5
assign("j",4)
j
```

## 4.3 Data
### 4.3.1 Numerical data

```{r}
class(x) #"numeric"
is.numeric(x) #TRUE
i<-5L #integer
is.integer(i) #TRUE
is.numeric(i) #TRUE
class(4L) #integer
class(2.8) #numeric
```

### 4.3.2 Text data

```{r}
x<-"data"
y<-factor("data")
y<-"data"
class(x) #character
nchar(x) #4 = number of character
nchar(452) #3
nchar(y) #error - y requires a character vector
```

### 4.3.3 date

```{r}
date1<-as.Date("2012-06-28")
class(date1) #date
as.numeric(date1) #15519

date2<-as.POSIXct("2012-06-28 17:42")
date2
class(date2) #[1] "POSIXct" "POSIXt" 
as.numeric(date2) #[1] 1340872920
```

Lubridate, chron packages are used to treate time or date such as an object.
-as.numeric/as.date (): change the type of object
```{r}
class(date1) #date
class(as.numeric(date1)) #numeric
```

### 4.3.4 Logical 

logical is binary values eithrer TRUE(1) or FALSE (0)
```{r}
TRUE*5 #5
FALSE*5 #0

k<-TRUE
class(k) 
is.logical(k) #TRUE
2==3
2!=3
2<3
2<=3
"data" < "stat" #number of character
class("data")

```

#4.4 Vector
##4.4.1 vector calculation

We set the basic vector, and can calculate sum/deduct/devide without loop.

```{r}
x<-c(1,2,3,4,5,6)
x+2
x-3
x^2
sqrt(x)
```

c is the function to create a vector, and we can use ":" operator, to calculate sequential numbers. 
```{r}
1:10
10:1
-2:3
5:-7
```

Vector operator can be expanded (e.g., there are two vectors with same length, and computation of each vector components once).

```{r}
x<-1:10
y<--5:4
x+y
x-y
x/y  
x**y # x^y: x to yth power
length(x)
length(x*y)
```

Two vectors with different length needs more complex computation.
Generally, a vector with shorter length is used multiple times. 

```{r}
x+c(1,2)
x+c(1,2,3)

x<=5
x>y
```

All function is used to test whether all values satisfy comparative statistics. 
```{r}
x<- 10:1
y<- -4:5
all(x<y)
```
 
- nchar function is used toward each component of vector.
```{r}
q<-c("Hockey","Football","Baseball","Curling","Rugby",
     "Lacrosse", "Bascketball","Tennis","Cricket","Soccer")
nchar(q)
nchar(y)
```

To access vector coponent, [] is used. To extract first component of x vector, x[1], x[1:2] for first two components. If components to be extracted are not sequential, x[c(1.4)] expression is usefl.

```{r}
x[1]
x[1:2]
x[c(1,4)]
```

The [] expression works for numeric, logical, character classes. We can also name vector before/after making a vector.
```{r}
c(One="a",Two="y",Last="r")
w<-1:3
names(w)<-c("a","b","c")
w
```

### 4.4.2 Factor vector
Factor is a crucial concept to construct a model.
First, we add additional components to the vector q.

```{r}
q2<-c(q,"Hockey","LAcrosse","Hockey","Water Polo",
      "Hockey","LAcrosse")
```

We can transform this vector into factor by as.factor function.
```{r}
q2Factor<-as.factor(q2)
q2Factor
```

After q2Factor components are listed, levels are also listed. Factor's level lists non-duplicate figures. 

```{r}
as.numeric(q2Factor)
```

Geenrally, no attention to the order of levels is required for factor. In addition, all level are treated same. However, there are occations factor order becomes significant.Ordered argument is set TRUE so that factor is ordere according to level argument.
```{r}
factor(x=c("High School","College","Masters","Doctorate"),
       levels=c("High School","College","Masters","Doctorate"),
       ordered=TRUE)
```

Factor keeps identical items, we could reduce size of variables.

#4.6 Function command
apropos() is useful to search specific function by keyword
```{r}
apropos("mea")
?kmeans
```

## 4.7 Missing Value "欠損値"
Missing value plays an important role for statistics and calculation. There are two types of missing values; NA and NULL.

### 4.7.1 NA
NA is shown as a component of vector. is.na() could test whether there is any missing value in vector.
- is.na: test existence of missing value
```{r}
z<-c(1,2,NA,8,3,NA,3)
z
is.na(z)
```

NA can be input by inserting NA, and corresonds to every class of vector. 
```{r}
zChar<-c("Hockey",NA,"LAcrosse")
zChar
is.na(zChar)
```

多重代入法 is a popular method to deal with statistical analysis. Details is available in chapter 25 of "Data Analysis Using Regression and Multilevel/Hierachical Models".

### 4.7.2 NULL
NULL cannot be insite vector, as it disappears in the vector after its used. 
```{r}
z<-c(1,NULL,3)
z
```

NULL is not saved in the c vector.We can test if there is any NULL item by is.null function ().
```{r}
d<-NULL
is.null(d)
is.null(7)
```


---------------------------------
#Chapter 5: High level data structure
We can treat high dimentional/level data frame by R, with data.frame, matrix, list,array.

## 5.1. data.frame
data.frame is similar to excel spreadsheet with row/columns(obs - row, variables - columns).Each column has a same length vector, and can be treated with different class of data.The data.frame function () is frequently used to form data.frame.

```{r}
x<-10:1
y<--4:5
q<-c("Hockey","Football","Baseball","Curling","Rugby",
     "Lacrosse","Bascketball","Tennis","Cricket","Soccer")
theDF<-data.frame(x,y,q)
theDF
```

In the above code, 10*3 data.frame was formed. Each column name can be changed in the data.frame function.
```{r}
theDF<-data.frame(First=x, Second=y, Sport=q)
theDF
```

The data.frame is a complex obeject with multiple characters. To quickly check number of rows/colmns, nrow/ncolumn () functions are used.
```{r}
nrow(theDF)
ncol(theDF)
dim(theDF)
```

Name () function is used to check name of columns, and such column names can be changed easily. 
```{r}
names(theDF)
names(theDF)[3]

rownames(theDF)
rownames(theDF)<- c("One","Two","Three","Four","Five","Six","Seven","Eight","Nine","Ten")
rownames(theDF)
rownames(theDF)<-NULL
rownames(theDF)
```

head () function is useful for checking first few rows. class function () can be used to detect data.frame.
```{r}
head(theDF)
head(theDF,n=7)
tail(theDF)
class(theDF)
```

data.frame has each column as individual vector with different class, thus , thus we can access each column.For accesing specific row, argument "$" or "[]" could be used.

```{r}
theDF$Sport
theDF[3,2] # For [], we need to input row/column no.
theDF[3,2:3]
theDF[c(3,5),2] #row3, 5 with column 2
theDF[,c("First","Sport")]
```

```{r}
#Sport column only
theDF[,"Sport"]
class(theDF[,"Sport"]) #factor is reverted as its only one column
theDF["Sport"]
class(theDF["Sport"])
```

drop=FALSE is set if we want to extract only one column data.frame with [].
```{r}
theDF[,"Sport",drop=FALSE]
class(theDF[,"Sport",drop=FALSE])
theDF[,3,drop=FALSE]
class(theDF[,3,drop=FALSE])
```

In section 4.4.2, factor is a special class, and we would like to confirm that such class can be exressed in data.frame as well.
- Model.matrix() is used with indicator variables (dummy).This results in 1 in case such row includes such level, otherwise 0.
```{r}
newFactor<-factor(c("Pennsylvania","New York","New JErsey","New York","Tennessee","Massachusetts","Pennsylvania","New York"))
model.matrix(~newFactor-1)
```

## 5.2 List
there is a case we need a List storing multiple types of objects.List can deal with numeric, character, both, and even data.frame.
```{r}
list(1,2,3) # three components
list(c(1,2,3)) # one vector with three components

list3<-list(c(1,2,3),3:7)
# first: a vector with three comps
# second: a vector with five comps

list4<-list(theDF,1:10)
list4
# second: a vector with ten numbers
```

The list can be named with names() function. Use pair of name and figures when list is created to give name. 
```{r}
list5<-list(theDF, 1:10, list3)

names(list5)
names(list5)<-c("data.frame","vector","list")
list5

list6<-list(TheDataFrame=theDF, THeVector=1:10, TheList=list)
names(list6)
```

Vector () function is used to make a ideal length of blank list. 
```{r}
(emptyList<-vector(mode="list",length=4))
```

To access each component of list, we should use [[]], and set number or name. By this function, only one item can be accessed.
```{r}
list5[[1]]
list5[["data.frame"]]

list5[[1]]$Sport
list5[[1]][,"Second"]
list5[[1]][,"Second",drop=FALSE]
```

To add new component to list, new syntax (number or name) is attached.
```{r}
length(list5)
list5[[4]]<-2 #without name
length(list5)

list5[["NewElement"]]<-3:6
list5
```


## 5.3 Matrix
Matrix is a basic mathmatical structure. There are row, column, similar to data.frame, however, all components are required to be same class/type in matrix. The most common matrix is numeric, and add/deduct/multiply/divide can e calculated. - nrow ()
- ncol ()
- dim () functions are available
```{r}
A<-matrix(1:10,nrow=5)
B<-matrix(21:30,nrow=5)
C<-matrix(21:40,nrow=2)
A
B
C
```

```{r}
# matrix basic calculation
# To calculate A*B, A's column and B'row need to be indentical
A+B
A*B
A==B
```

Transposed matrix can be calculated with t() function. 

```{r}
# Transposed matrix
A %*% t(B)
colnames(A)<-c("Left","Right")
rownames(A)<-c("1st","2nd","3rd","4th","5th")
colnames(B)<-c("First","second")
rownames(B)<-c("One","Two","Three","Four","Five")

colnames(C)<-LETTERS(1:10)
rownames(C)<-c("Top","Bottom")
```

When matrix is transposed, we should be careful that row name and column name is conversed. 
```{r}
t(A) # A:5*2 C:2*5
A %*% C
```


## 5.4 Array
Array is multidimentional vector. Array's components need to have same type. [] can be used to access specific component,like Vector. In[], the first item is row number, second is column number etc. 

The difference between matrix and array is that array can be used for non-limited dimension, while matrix is limited to second dimension.

```{r}
theArray<-array(1:12,dim=c(2,3,2))
theArray
```

```{r}
theArray[1,,]
theArray[1,,1]
theArray[,,1]
```


---------------------------------
# Chapter6: Loading data

## 6.1. Loading CSV file
CSV file can be easily loaded using read.table function. 
- read.table(): if CSV is loaded as data.frame. 
 - file: the file to be loaded
 - header: Yes, if first row is column name
 - sep: Mark to split data (",")
 - stringAsFactors: FALSE to prevent make character column into factor column (character column is easier to deal as data)
 
* stringAsFactors is used also for data.frame.

```{r}
theURL<-"http://www.jaredlander.com/data/Tomato%20First.csv"
tomato<-read.table(file=theURL,head=TRUE,sep=",")
head(tomato)
```

When we proces theDF data, the theDF$Sport is easier to analyze. There are multiple arguments available for read.table () function.
- quote: used when data is labled with ""
- colClasses:set each column's data class/type

```{r}
x<-10:1
y<--4:5
q<-c("Hockey","Football","Baseball","Curling","Rugby","Lacrosse","Basketball","Tennis","Cricket","Soccer")
theDF<-data.frame(First=x,Second=y,Sport=q,stringAsFactors=FALSE)
theDF$Sport
```

In case where CSV file uses ,(区切文字) in each data.
- read.csv2(or read.delim2)

## 6.2. Loading Excel data
The easiest way to load excel file is to transform excel to CSV file. Even though there are packages such as gdata, XLConnect, xlsReadWrite, these packages require JAVA/Perl.

## 6.3. Loading from Database
Most database provides ODBC connectin, for instance, Mocrosoft SQL server, DB2, MySQL, Miscrosoft Access. Thus, R allows ODBC by RODBC package. 

(1) Construct DSN: 
DSN is constructed as sentence for odbcConnect ().
- argument uid
- password
(2) 

```{r}
install.packages("RODBC")
require(RODBC)
db<-odbcConnect("QV Training")
```

By the above command, we are read to run query on database. sqlQuery () function is used, and very usefl for any complet SQL query. sqlQuery provides data.frame, and has a stringAsFactors as its argument. 
```{r}
# simple select
ordersTable<-sqlQuery(db,"SELECT*FROM Orders",
                      stringsAsFactors=FALSE)
detailsTable<-sqlQuery(db, "SELECT*FROM[Order Details",
                      stringsAsFactors=FALSE)
# join two tables
longQuery<-"SELECT * FROM Orders, [Order Details]
WHERE Orders.ORderID = [Order Details].OrderID"
detailsJoin<-sqlQuery(db, longQuery, stringsAsFactors=FALSE)

head(ordersTable)
head(detailsTable)
heead(detailsJoin)
```

## 6.5 R Binary File
RData file is useful to transfer data to another R programmer. RData file is a binary file as a object or multiple pbjects, and can be transfered through Windows, Mac, Linux.

```{r}
# save tomato data.frame
save(tomato,file="C:/Users/kojikm.mizumura/Desktop/Data Science/みんなのR/tomato.rdata")
rm(tomato)
head(tomato)
load("C:/Users/kojikm.mizumura/Desktop/Data Science/みんなのR/tomato.rdata")
head(tomato)

n<-20
r<-1:10
save(n,r,w,file="C:/Users/kojikm.mizumura/Desktop/Data Science/みんなのR/3. Dataset/multiple.rdata")
rm(n,r,w)
load("C:/Users/kojikm.mizumura/Desktop/Data Science/みんなのR/3. Dataset/multiple.rdata")
```

## 6.6 Default Packages
To check available default datasets in each package, data() function is useful.
  
```{r}
data()
```

##6.7 Webscraping

readHTMLTable () function:
- which: pick which table in case there are multiple tables
- Header: No, in case there no header in table
- stringAsFactors: FALSE not to make character column into factor

```{r}
install.packages("XML")
require(XML)
theURL1<-"https://www.jaredlander.com/2012/02/another-kind-of-super-bowl-pool/"
bowlPool<-readHTMLTable(theURL1, which=1, header=FALSE,
                        stringsAsFactors=FALSE)
bowlPool
```


---------------------------------
# Chap7: Statistical Graph
## 7.1 Basic graphics

### 7.1.1. Histogram
Basic graph for one variable is histogram. 
- diamonds dataset: distribution by Carat
```{r}
require(ggplot2)
data(diamonds)
head(diamonds)
```

```{r}
hist(diamonds$carat, main="Carat Histgram",xlab="Carat")
```


### 7.1.2 Scatterplot
Scatterplot is useful to plot two variables 
- diamonds dataset: 
```{r}
plot(price~carat, data=diamonds)
plot(diamonds$carat, diamonds$price)
```

### 7.1.3 Boxplot
The Box plot shows 1st and 3rd quartile (50% range from center is ciculated)
```{r}
boxplot(diamonds$carat)
```

## 7.2 ggplot2
###7.2.1 Histgraom Density chart by ggplot
ggplot has a complex syntax (structure), but allows user to dipict by size,shape, color etc. 

```{r}
install.packages("ggplot2")
require(ggplot2)
ggplot(data=diamonds)+geom_histogram(aes(x=carat))
```

```{r}
ggplot(data=diamonds)+geom_density(aes(x=carat), fill="grey50")
```

### 7.2.2. Scatterplot by ggplot
```{r}
ggplot(diamonds, aes(x=carat,y=price))+geom_point()
g<-ggplot(diamonds,aes(x=carat,y=price))
g+geom_point(aes(color=color))
g+geom_point(aes(color=color))+facet_wrap(~color)
g+geom_point(aes(color=color))+facet_grid(cut~clarity)
```

### 7.2.3 Boxplot / Violin-plot by ggplot
Violin plot is simiar to boxplot, but provides more information than boxplot. By using violin plot, we can depict multiple layers (geoms) at the same chart.
```{r}
ggplot(diamonds, aes(y=carat, x=1))+geom_boxplot()
ggplot(diamonds, aes(y=carat,x=cut))+geom_boxplot()

ggplot(diamonds, aes(y=carat,x=cut))+geom_violin()
ggplot(diamonds,aes(y=carat,x=cut))+geom_point()+geom_violin()
ggplot(diamonds,aes(y=carat,x=cut))+geom_point()+geom_point()
```

### 7.2.4 Line by ggplot

ggplot2 depicts economics pop line by identifying date data.
However, there are cases we need to input aes(group=1) for geom_line(). 

```{r}
head(economics)
ggplot(economics,aes(x=date,y=pop))+geom_line()
```

---------------------------------------
# Chap8: Write R Function

## 8.1 Hello World
simple function to show "Hello, World".
- perod (.) does not have a special meaning
- Similar other arguments, "<-" assigns function to object same as variabile
```{r}
say.hello<-function()
{
  print("Hello, World!")
}
```

## 8.2 Argument of function
sprintf () function 
- first argument:special input word
- second argument:next word
```{r}
sprintf("Hello %s", "Jared") # one word
sprintf("Hello %s, today is %s", "Jared","Sunday") # two words

hello.person<-function(name)
{
  print(sprintf("Hello %s",name))
}
hello.person("Jared")
hello.person("Bob")
hello.person("Sarah")
```

Argument can be used as a variable in function, and can be treated same as other variables and argument to further call for another function inside the function.
```{r}
hello.person<-function(first,last)
{
  print(sprintf("Hello %s %s",first, last))
}

# set by position
hello.person("Jared","LAnder")
# set by name
hello.person(first="Jared",last="Lander")
# set by name in oppostite
hello.person(last="Lander", first="Jared")
# set by one name
hello.person("Jared",last="Lander")
hello.person(first="Jared","Lander")
hello.person(last="Lander","Jared")
```

### 8.2.1 Default argument
R has a default setting for multiple arguments (no need to set argument individually). 

```{r}
hello.person<-function(first,last="Doe")
{
  print(sprintf("Hello %s %s", first, last))
}
hello.person("Jared") #not set last name
hello.person("Jared","Lander") #set different last name
```


### 8.2.2 Additional argument 
R has a special operator ("演算子", "..."") allow function to take arguments not needed for defining function.
```{r}
# Additional argument
hello.person("Jared",extra="Goodbye") #error

# two effective arguments, extract third argument
hello.person("Jared","Lander","Goodbye")

hello.person<-function(first,last="Doe",...)
{
  print(sprintf("Hello %s %s",first,last))
}
hello.person("Jared",extra="Goodbye")
hello.person("Jared","Lander","Goodbye")
```

## 8.3 Return value
Function is generally used to calculate some values, and needs mechanism to retrun calculation results back to function.

There are two methods for R
- (1) return last row value automatically
- (2) use return command to select which value to be returned/which function to be closed (finished)

```{r}
# make function without specific definition
double.num<-function(x)
{ x*2}
double.num(5)

# define return mechanism
double.num<-function(x)
{return(x*2)}
double.num(5)

# additional argument of 17 after return x* value / x*2 function is already over, and the code was not conducted
double.num<-function(x)
{return(x*2)
  print("Hello!")
  return(17)}
double.num(5)
```

## 8.4 do.call
do.call () function is used to set name of function (not frequently used).List is used to set arguments.

```{r}
do.call("hello.person",args=list(first="Jared",last="Lander"))
do.call(hello.person,args=list(first="Jared",last="Lander"))

run.this<-function(x,func=mean)
{
  do.call(func,args=list(x))
}
run.this(1:10,mean) #set average
run.this(1:10,sum) #set sum
run.this(1:10,sd) #set sd
```


---------------------------------------
# Chapter9: Control Sentence
Control sentence controls program and allows different codes based on test result (e.g., logic, TRUE, FALSE). Main control sentences are as follows.
- if
- else
- ifelse
- switch

## 9.1 if and else
```{r}
as.numeric(TRUE)
as.numeric(FALSE)

1==1
1<1
1>=1
1!=1

# if sentence to control this test
toCheck<-2
if(toCheck==1)
{
  print("hello")
}

```


if sentence is close to function in terms that all sentences are within (). We define else sentence in case the the situation is FALSE circumustance. 
- TRUE: works as 1 (TRUE)
```{r}
check.bool<-function(x)
{
  if(x==1)
  {
    print("hello") # if x=1, "Hello"
  } else
  {
    print("goodbye") #otherwise "goodbye"
  }
}
check.bool(1)
check.bool("k")
check.bool(TRUE)
```

In case of testing multiple options, we use else if () respectvely. 
```{r}
check.bool<-function(x)
{
  if(x==1)
  {
    print("Hello")
  }else if (x==0)
  {
    print("Confused")
  }else
  {
    print("Unknown")
  }
}
check.bool(1)
check.bool(0)
check.bool("k")
```

## 9.2 Switch 
When we test multiple options , switch would be more useful than else if 
- first argument: values to be tested
- second argument: option values, results
```{r}
use.switch<-function(x)
{
  switch(x,
         "a"="first",
         "b"="second",
         "z"="last",
         "c"="third",
         "other")
}
use.switch("a")
use.switch("e")
```

When the first argument is numerical, order of the first argument is used instead of name of the first argument. 
```{r}
use.switch(1)
use.switch(4)
```

## 9.3. ifelse
ifelse is close to if function in excel.
- first: condition to be tested
- second: returned value when the test is TRUE
- third: returned value whenthe test is FALSE
```{r}
# test whether 1=1
ifelse(1==1, "Yes","No")
ifelse(1==0, "Yes","No")
toTest<-c(1,1,0,1,0,1)
ifelse(toTest==1, "Yes","No")

# we can access element of first argument (test value)
ifelse(toTest==1, toTest*3, toTest)
ifelse(toTest==1, toTest*3, "Zero")

# NA value
toTest[2]<-NA
toTest
ifelse(toTest==1, "Yes","No")
ifelse(toTest==1, toTest*3, toTest)
ifelse(toTest==1, toTest*3, toTest)
ifelse(toTest==1, toTest*3, "ZERO")
```

## 9.4 Multiple tests

When testing multiple conditions, double expressin (e.g.,&&, ||) are used in the same if sentence.The expression "and" (multiply) is priotized against "or" (add).

```{r}
a<-c(1,1,0,1)
b<-c(2,1,0,1)
# check condtion a and b respectively
ifelse(a==1 & b==1, "Yes", "No")
# check condition a and b as one condition
ifelse(a==1 && b==1, "Yes", "No")
```


# Chapter10: Loop
R beginners often use vector, list, data.frame with loop functions. It is desirable to use vecotrized coding, but the below outlines for loop, while loop functions.

## 10.1 For Loop

For loop function is most frequently used. 
- for loop: iterate process for index (vector)

```{r}
for (i in 1:10)
{print(i)}

# print () function (vectorized) works for the same results 
print(1:10)
```






